<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>从Built-in到URP | 阿卡林</title><meta name="keywords" content="URP"><meta name="author" content="阿卡林"><meta name="copyright" content="阿卡林"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HLSL的语法。">
<meta property="og:type" content="article">
<meta property="og:title" content="从Built-in到URP">
<meta property="og:url" content="http://example.com/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/index.html">
<meta property="og:site_name" content="阿卡林">
<meta property="og:description" content="HLSL的语法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2021-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2021-05-26T15:26:46.430Z">
<meta property="article:author" content="阿卡林">
<meta property="article:tag" content="URP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从Built-in到URP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-26 23:26:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">阿卡林</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从Built-in到URP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-22T01:00:00.000Z" title="发表于 2021-05-22 09:00:00">2021-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-26T15:26:46.430Z" title="更新于 2021-05-26 23:26:46">2021-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从Built-in到URP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HLSL语法"><a href="#HLSL语法" class="headerlink" title="HLSL语法"></a>HLSL语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>  <strong>bool</strong> – true or false.</p>
</li>
<li><p>  <strong>float</strong>- 32位浮点数。通常用于世界空间位置，纹理坐标或涉及复杂函数（例如三角函数或幂/幂）的标量计算。</p>
</li>
<li><p>  <strong>half</strong> – 16位浮点数。通常用于短向量，方向，对象空间位置，颜色。</p>
</li>
<li><p>  <strong>double</strong> – 64位浮点数。不能用作输入/输出</p>
</li>
<li><p>  <strong>fixed</strong> – 仅在内置着色器中使用，在URP中不支持，请改用<strong>half</strong> 。</p>
</li>
<li><p>  <strong>real</strong> – 一般手机平台相当于half，pc平台相当于float。</p>
</li>
<li><p>  <strong>int</strong> – 32位有符号整数</p>
</li>
<li><p>  <strong>uint</strong> – 32位无符号整数（GLES2除外，不支持此整数，而是将其定义为int）。</p>
</li>
<li><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3></li>
<li><p> float4 – 包含4个浮点的向量</p>
</li>
<li><p>  float3 – 包含3个浮点的向量</p>
</li>
<li><p>  float2 – 包含2个浮点的向量</p>
</li>
<li><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3></li>
<li><p>  float4x4 – 4行，4列</p>
</li>
<li><p>  float4x3 – 4行，3列</p>
</li>
<li><p>  float2x1 – 2行，1列</p>
</li>
<li><p>  float1x4 – 1行，4列</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float3x3 matrix = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">                   <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">                   <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">float3 row0 = matrix[<span class="number">0</span>]; <span class="comment">// (0, 1, 2)</span></span><br><span class="line">float3 row1 = matrix[<span class="number">1</span>]; <span class="comment">// (3, 4, 5)</span></span><br><span class="line">float3 row2 = matrix[<span class="number">2</span>]; <span class="comment">// (6, 7, 8)</span></span><br><span class="line"><span class="type">float</span> row1column2 = matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 注意我们也可以这样做</span></span><br><span class="line"><span class="type">float</span> row1column2 = matrix[<span class="number">1</span>]<span class="number">.2</span>;</span><br></pre></td></tr></table></figure>
<p>矩阵通常用于不同坐标空间之间的转换。为此，我们需要进行矩阵乘法，可以使用<strong>mul</strong>函数来完成，传统的*/不在适用。</p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>可以在着色器中指定数组，尽管Shaderlab属性或材质检查器不支持它们，并且必须从C＃脚本中进行设置。必须在着色器中指定数组的大小，并且数组大小应保持恒定以防止出现问题。如果我们不知道数组的大小，则需要设置最大值并以0s传入数组填充。我们可以指定另一个float来作为需要遍历数组的长度，例如此处的示例。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> _Array[<span class="number">10</span>]; <span class="comment">// Float array</span></span><br><span class="line">float4 _Array[<span class="number">10</span>]; <span class="comment">// Vector array</span></span><br><span class="line">float4x4 _Array[<span class="number">10</span>]; <span class="comment">// Matrix array</span></span><br></pre></td></tr></table></figure>

<p>设置浮点数组时，请使用<strong>material.SetFloatArray</strong>或<strong>Shader.SetGlobalFloatArray</strong>。还有<strong>SetVectorArray</strong>和<strong>SetMatrixArray</strong>及其全局版本</p>
<h3 id="其他种类"><a href="#其他种类" class="headerlink" title="其他种类"></a>其他种类</h3><p>HLSL还包括其他类型，例如“纹理”和“采样器”，可以使用URP中的以下宏进行定义。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXTURE2D(textureName);</span><br><span class="line">SAMPLER(sampler_textureName);</span><br></pre></td></tr></table></figure>
<p>还有缓冲区，尽管我从未真正使用过它们，所以对它们的用法并不熟悉。它们是使用<strong>material.SetBuffer</strong>或<strong>Shader.SetGlobalBuffer</strong>从C＃设置的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef SHADER_API_D3D11</span></span><br><span class="line">StructuredBuffer&lt;float3&gt; <span class="keyword">buffer</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="comment">// I think this is only supported in Direct3D 11?</span></span><br><span class="line"><span class="comment">// and also require #pragma target 4.5 or higher?</span></span><br><span class="line"><span class="comment">// see https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html</span></span><br></pre></td></tr></table></figure>

<p>你可能还希望研究HLSL的其他部分，例如<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-flow-control">流控制</a> （if，for，while等），但是如果我们熟悉语法，则其语法基本上与C＃相同。我们还可以<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-operators">在此处</a>找到HLSL支持的所有运算符的列表。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>HLSL中的函数声明与C＃非常相似。这是一个例子：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 example(float3 a, float3 b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中float3是返回类型，示例是函数名称，括号内是传递给函数的参数。在没有返回类型的情况下，将使用void。您还可以在参数类型之前使用“ out”来指定输出参数，如果希望它成为可编辑并回传的输入，则可以使用“ inout”来指定输出参数。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>宏在编译着色器之前进行处理，并且在使用宏时将替换为带有替换参数的定义。例如</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define EXAMPLE(x, y) ((x) * (y))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = EXAMPLE(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">float3 a = float3(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">float3 f2 = EXAMPLE(a, float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// becomes :</span></span><br><span class="line"><span class="type">float</span> f = ((<span class="number">3</span>) * (<span class="number">5</span>));</span><br><span class="line"><span class="type">float</span> a = <span class="type">float</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">float3 f2 = ((a) * (float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line"><span class="comment">// then the shader is compiled.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Note that the macro has () around x and y.</span></span><br><span class="line"><span class="comment">// This is because we could do :</span></span><br><span class="line"><span class="type">float</span> b = EXAMPLE(<span class="number">1</span>+<span class="number">2</span>, <span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line"><span class="comment">// becomes :</span></span><br><span class="line"><span class="type">float</span> b = ((<span class="number">1</span>+<span class="number">2</span>) * (<span class="number">3</span>+<span class="number">4</span>)); <span class="comment">// 3 * 7, so 21</span></span><br><span class="line"><span class="comment">// If those () wasn&#x27;t included, it would instead be :</span></span><br><span class="line"><span class="type">float</span> b = (<span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)</span><br><span class="line"><span class="comment">// which equals 11 due to * taking precedence over +</span></span><br></pre></td></tr></table></figure>

<p>他们还可以做一些功能无法做到的事情。例如 ：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Usage :</span></span><br><span class="line">OUT.uv = TRANSFORM_TEX(IN.uv, _MainTex)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// becomes :</span></span><br><span class="line">OUT.uv = (IN.uv.xy * _MainTex_ST.xy + _MainTex_ST.zw);</span><br></pre></td></tr></table></figure>

<p>“##”运算符是一种特殊情况，其中宏可能很有用。它使我们可以将名称和_ST部分连接起来，从而为此用法输入生成**_MainTex_ST**。如果省略##部分，它将仅生成“**name_ST**”，从而导致错误，因为尚未定义。（当然，仍然需要定义**_MainTex_ST**，但这是预期的行为，因为在纹理名称后附加**_ST**是Unity处理**纹理的平铺和偏移值**的方式）。</p>
<h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><p>URP LIGHTMODE TAGS :</p>
<ul>
<li>  <strong>UniversalForward</strong> – 用于前向渲染</li>
<li>  <strong>ShadowCaster</strong> – 用于投射阴影</li>
<li>  <strong>DepthOnly</strong> – 似乎在为场景视图渲染深度纹理时使用，而不是在运行中使用吗？不过，某些渲染器功能可能会使用它。</li>
<li>  <strong>Meta</strong> – 仅在光照贴图烘焙期间使用</li>
<li>  <strong>Universal2D</strong> – 在启用 2D 渲染器时使用，而不是前向渲染器。</li>
<li>  <strong>UniversalGBuffer</strong> – 与延迟渲染有关。我认为这是测试功能。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot; = &quot;UniversalForward&quot; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在子着色器中定义多个Pass块，但是每个都应该用一个特定的LightMode标记(见下面)。URP使用了单通道前向渲染器，所以只有第一个“通用前向”通道(GPU支持的)将用于渲染对象——你不能同时渲染多个对象。虽然我们可以让其他传递没有标记，但要注意<strong>它们将中断SRP批处理程序的批处理</strong>。相反，我们建议使用单独的着色器/材质，无论是在单独的MeshRenderers上，还是使用Forward Renderer上的Render Objects特性，用一个overrideMaterial在一个特定的图层上重新渲染对象。</p>
</blockquote>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在Shaderlab示例中，我们有一个<strong>HLSLINCLUDE</strong>，它会自动将代码包含在Subshader内部的每个Pass中。</p>
<p>我们可以使用<strong>UnityPerMaterial CBUFFER</strong>来确保着色器兼容SRP批处理。这个<strong>CBUFFER</strong>需要包括所有公开的属性(与Shaderlab属性块中的相同)。但它不能包括其他未公开的变量，纹理也不需要被包括。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HLSLINCLUDE</span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span><br><span class="line"> </span><br><span class="line">    CBUFFER_START(UnityPerMaterial)</span><br><span class="line">    float4 _BaseMap_ST;</span><br><span class="line">    float4 _BaseMap_TexelSize;</span><br><span class="line">    float4 _BaseColor;</span><br><span class="line">    <span class="comment">//float4 _ExampleDir;</span></span><br><span class="line">    <span class="comment">//float _ExampleFloat;</span></span><br><span class="line">    CBUFFER_END</span><br><span class="line">ENDHLSL</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是**_BaseMap_ST**与**_BaseMap_TexelSize**是两个东西，前者是纹理的缩放与偏移，而后者代表纹理的大小。</p>
</blockquote>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>在定义顶点或片段着色器功能之前，我们需要定义一些用于将数据传入和传出的结构。在内置函数中，它们通常被命名为“<strong>appdata</strong>”和“<strong>v2f</strong>”（顶点到片段的缩写），而URP着色器则倾向于使用“ <strong>Attributes</strong>”和“ <strong>Varyings</strong> ”。这些只是名称，可能不太重要。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Attributes &#123;</span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    float4 color        : COLOR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该属性结构将输入到<strong>顶点着色器</strong>。它允许我们使用大写字母中被称为语义的部分从网格中获取每个顶点的数据。其中包括：顶点位置（<strong>POSITION</strong>），顶点颜色（<strong>COLOR</strong>）和<strong>UV</strong>（又称为纹理坐标）。网格具有8个不同的UV通道，可以通过<strong>TEXCOORD0</strong>到<strong>TEXCOORD7</strong>进行访问。</p>
<p>我们还可以通过<strong>NORMAL</strong>访问顶点法线，并通过<strong>TANGENT</strong>访问切线。</p>
<p>在这些结构之后，您通常还会看到已定义了<strong>纹理</strong>和<strong>采样器</strong>（虽然纹理位于着色器属性中，但尚未在hlsl中定义。其他属性包括在<strong>CBUFFER</strong>中）。在URP中，我们使用以下内容：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br></pre></td></tr></table></figure>

<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>我们的顶点着色器需要做的主要事情是将网格从对象空间位置转换为剪辑空间位置。为了在目标屏幕位置正确渲染片元/像素。</p>
<p>在内置着色器中，您可以使用<strong>UnityObjectToClipPos</strong>函数执行此操作，但是URP已将其重命名为<strong>TransformObjectToHClip</strong>（可以在函数库SpaceTransforms.hlsl中找到）。也就是说，还有另一种方法来处理URP中的转换，如下所示。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Varyings vert(Attributes IN) &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line"> </span><br><span class="line">    VertexPositionInputs positionInputs = GetVertexPositionInputs(IN.positionOS.xyz);</span><br><span class="line">    OUT.positionCS = positionInputs.positionCS;</span><br><span class="line">    <span class="comment">// Or this :</span></span><br><span class="line">    <span class="comment">//OUT.positionCS = TransformObjectToHClip(IN.positionOS.xyz);</span></span><br><span class="line"> </span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    OUT.color = IN.color;</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们从<strong>Attributes</strong>中输入对象空间的位置，并获得一个<strong>VertexPositionInputs</strong>结构，其中包含：<ul>
<li>  positionWS，在世界空间中的位置</li>
<li>  positionVS，视图空间中的位置</li>
<li>  positionCS，裁剪空间中的位置</li>
<li>  positionNDC，标准化设备坐标中的位置</li>
</ul>
</li>
<li>顶点着色器还负责将数据传递到片段。对于顶点颜色，这只是一个简单的<code>OUT.color = IN.color;</code>。</li>
<li>如果我们希望能够对纹理进行采样，则还需要传递模型的UV（纹理坐标）。虽然我们可以做<code>OUT.uv = IN.uv;</code>（假设两者均为float2），通常会使用<strong>TRANSFORM_TEX</strong>宏，该宏采用uv和texture属性名称，并应用材质检查器的偏移和平铺进行矫正（存储在“ _BaseMap” +“ _ ST”中，S用于比例尺和T））。此宏位于内置和URP中（在core / ShaderLibrary / Macros.hlsl内部，应自动包含在Core.hlsl中）。 实际上，这只是<code>IN.uv.xy * _BaseMap_ST.xy + _BaseMap_ST.z</code>的简写，因此您也可以这样写（将_BaseMap换成预期的纹理属性。<code>（texture）_ST</code>float4变量还必须添加到<strong>UnityPerMaterial CBUFFER</strong>（已在属性部分中讨论过）。</li>
</ol>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VertexNormalInputs normalInputs = GetVertexNormalInputs(IN.normalOS, IN.tangentOS);</span><br></pre></td></tr></table></figure>

<p><strong>GetVertexNormalInputs</strong>可用于将对象空间的法线和切线转换为世界空间。它包含:</p>
<ul>
<li>  normalWS，在世界空间中的法线向量</li>
<li>  tangentWS，在世界空间中的切线向量</li>
<li>  bitangentWS，在世界空间中的副切线向量</li>
</ul>
<p>还有一个仅将法线作为输入的版本，将tangentWS保留为（1,0,0），bitangentWS保留为（0,1,0），或者您也可以改用<code>TransformObjectToWorldNormal(IN.normalOS)</code>。</p>
<h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(Varyings IN) : SV_Target &#123;</span><br><span class="line">    half4 baseMap = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> baseMap * _BaseColor * IN.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将生成一个着色器，该着色器基于_BaseMap纹理输出一个Half4颜色，该着色器还由_BaseColor和顶点颜色（<strong>IN.color</strong>）进行着色。</p>
<p><strong>SV_Target</strong>部分是与<strong>half4</strong>输出一起使用的语义，它告诉着色器它是颜色输出。</p>
<p>还有一个<strong>SV_Depth</strong>输出，它是一个浮点数，用于覆盖每个像素的Z缓冲区值。（可以将它们放入一个结构中以同时输出<strong>SV_Target</strong>和<strong>SV_Depth</strong>）。在大多数情况下，不需要覆盖它，对于许多GPU，它都会关闭某些基于深度缓冲区的优化，因此除非您知道自己在做什么和需要做什么，否则不要覆盖它。</p>
<p>我们的片段着色器使用URP ShaderLibrary提供的<strong>SAMPLE_TEXTURE2D</strong>宏对**_BaseMap**纹理进行采样，该宏将纹理，采样器和UV作为输入。</p>
<p>我们可能还想做的是，如果像素的alpha值低于某个阈值，则将其丢弃，以使整个网格都不可见。</p>
<p>例如，对于四边形上的草/叶纹理。既可以在不透明着色器中也可以在透明着色器中完成此操作，通常将其称为Alpha裁剪。如果您熟悉shadergraph，可以使用主节点上的“Alpha Clip Threshold”输入来处理它。</p>
<p>解决此问题的常用方法是提供**_Cutoff属性**以控制阈值，然后执行以下操作。（此属性必须添加到我们的Shaderlab属性以及UnityPerMaterial CBUFFER中以实现SRP Batcher兼容性）。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_BaseMap.a &lt; _Cutoff)&#123;</span><br><span class="line">    <span class="keyword">discard</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">clip(_BaseMap.a - _Cutoff);</span><br><span class="line"><span class="comment">// inside the fragment function, before returning</span></span><br></pre></td></tr></table></figure>

<p>环境光在URP下用_GlossyEnvironmentColor获取，但得到的效果可能与Builit-in下的结果相差较大，这时候可以考虑用球谐函数获取</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//URP使用的环境光</span></span><br><span class="line">half3 ambient = _GlossyEnvironmentColor</span><br><span class="line"><span class="comment">//使用球谐函数获取</span></span><br><span class="line">half3 ambient = SampleSH(worldNormal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//--Builit-in</span></span><br><span class="line">half3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br></pre></td></tr></table></figure>

<h2 id="关键字和着色器变体"><a href="#关键字和着色器变体" class="headerlink" title="关键字和着色器变体"></a>关键字和着色器变体</h2><h3 id="着色器变体"><a href="#着色器变体" class="headerlink" title="着色器变体"></a>着色器变体</h3><p>在着色器中，我们可以指定更多的**#pragma**指令，其中一些指令包括**multi_compile**和**shader_feature**。这些可用于指定用于将“着色器”代码的某些部分“打开”或“关闭”的关键字。着色器实际上被编译为多个版本的着色器，称为**着色器变体**。</p>
<p><code>MULTI_COMPILE</code></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile _A _B _C (...etc)</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，我们将生成着色器的三个变体，其中_A，_B和_C是关键字。</p>
<p>在着色器代码中，我们可以使用以下内容：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef _A</span></span><br><span class="line"><span class="comment">// 如果A启用，编译此代码</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#ifndef _B</span></span><br><span class="line"><span class="comment">// 当B被禁用时编译此代码，也就是只在A和C中。</span></span><br><span class="line"><span class="comment">// 注意#ifndef中额外的“n”表示“如果没有定义”</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="comment">// 如果B启用，编译此代码</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#if defined(_A) || defined(_C)</span></span><br><span class="line"><span class="comment">// 用A或c (aka与上面的相同，假设没有其他关键字)编译此代码</span></span><br><span class="line"><span class="comment">// 如果需要多个条件，则必须使用长形式的&quot;#if defined()&quot;</span></span><br><span class="line"><span class="comment">// 其中|| = or， &amp;&amp; = and</span></span><br><span class="line"><span class="comment">// 注意，因为关键字是在一个multi_compile语句中定义的</span></span><br><span class="line"><span class="comment">// 实际上不可能同时启用两者，所以&amp;&amp;在这里没有意义。</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 还有#elif，用于else if语句。</span></span><br></pre></td></tr></table></figure>

<p><code>SHADER_FEATURE</code></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma shader_feature _A _B</span></span><br></pre></td></tr></table></figure>

<p>这与<strong>multi_compile</strong>完全相同，但是未使用的变体将不包括在最终版本中。因此，在运行时启用/禁用这些关键字是不好的，因为它所需的着色器可能未包含在构建中！如果需要在运行时处理关键字，请改用<strong>multi_compile</strong>。</p>
<p>这些指令还有“顶点”和“片元”版本，可用于仅针对顶点或片段程序编译着色器变体，从而减少了变体的总数。例如 ：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile_vertex _ _A</span></span><br><span class="line"><span class="meta">#pragma multi_compile_fragment _ _B</span></span><br><span class="line"><span class="comment">// also shader_feature_vertex and shader_feature_fragment</span></span><br></pre></td></tr></table></figure>

<p>在此示例中，_A关键字仅用于顶点程序，_B仅用于片元。不能同时启用_A和_B的变体。Unity告诉我们，这会产生2个着色器变体，尽管当您查看实际的编译代码时，它更像是一个禁用两个着色器的着色器变体和两个“half”的变体。</p>
<h4 id="着色器变体的增长"><a href="#着色器变体的增长" class="headerlink" title="着色器变体的增长"></a>着色器变体的增长</h4><p>每增加一个multi_compile和shader_feature，它就会为启用/禁用关键字的每种可能组合生成越来越多的着色器变体。以以下为例：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile _A _B _C</span></span><br><span class="line"><span class="meta">#pragma multi_compile _D _E</span></span><br><span class="line"><span class="meta">#pragma shader_feature _F _G</span></span><br></pre></td></tr></table></figure>

<p>在这里，第一行将生成3个着色器变体。但是第二行需要为已启用_D或_E的那些变体生成2个着色器变体。</p>
<p>因此，A＆D，A＆E，B＆D，B＆E，C＆D和C＆E。现在有6个变体。</p>
<p>第三行，是这6个中的每一个的另外2个变体，因此我们现在总共有12个着色器变体。由于该行是shader_feature，因此某些变体可能不会包含在构建中。</p>
<p>每个添加了2个关键字的<strong>multi_compile</strong>都会使产生的变体数量加倍，因此包含10个变体的着色器将产生1024个着色器变体！它需要编译最终构建中需要包含的每个着色器变体，因此将增加构建时间以及构建大小。</p>
<h4 id="如何查看着色器的变体个数"><a href="#如何查看着色器的变体个数" class="headerlink" title="如何查看着色器的变体个数"></a>如何查看着色器的变体个数</h4><p>如果要查看一个着色器产生多少个着色器变体，请单击该着色器，然后在检查器中有一个“Compile and Show Code”按钮，旁边是一个小的下拉箭头，其中列出了所包含的变体数。如果单击“skip unused shader_features”，则可以切换以查看变体的总数。</p>
<p><img src="file:///E:/%5cGit%5cSiKi%5c%e6%96%87%e6%a1%a3%5cURP%5cBuilt-in%e5%88%b0URP.assets%5cimage-20201210114824886.png" alt="image-20201210114824886"></p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>每个项目最多还有256个关键字，因此最好遵循其他着色器的命名约定。</p>
<p>您还会注意到，对于许多<strong>multi_compile</strong>和<strong>shader_features</strong>而言，第一个关键字通常仅保留为“ _”。实际上，这实际上不会产生关键字，因此会为256个最大值的其他关键字留出更多空间。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile _ _KEYWORD</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#pragma shader_feature _KEYWORD</span></span><br><span class="line"><span class="comment">// 仅是shader_features的简写</span></span><br><span class="line"><span class="meta">#pragma shader_feature _ _KEYWORD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果您需要知道该关键字是否已禁用</span></span><br><span class="line"><span class="comment">// 然后我们可以这样做：</span></span><br><span class="line"><span class="meta">#ifndef _KEYWORD</span></span><br><span class="line"><span class="comment">// 或#if！defined（_KEYWORD）</span></span><br><span class="line"><span class="comment">// 或#ifdef _KEYWORD #else</span></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>

<p>我们还可以通过使用multi_compile和shader_feature的本地版本来避免耗尽最大的关键字数。这些生成的关键字对于该着色器来说是本地的，但是每个着色器最多也有64个本地关键字。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile_local _ _KEYWORD</span></span><br><span class="line"><span class="meta">#pragma shader_feature_local _KEYWORD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 还有local_fragment/vertex !</span></span><br><span class="line"><span class="meta">#pragma multi_compile_local_fragment _ _KEYWORD</span></span><br><span class="line"><span class="meta">#pragma shader_feature_local_vertex _KEYWORD</span></span><br></pre></td></tr></table></figure>

<h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>Universal RP不支持表面着色器，但是ShaderLibrary确实提供了帮助我们处理大量光照计算的功能。这些包含在<strong>Lighting.hlsl</strong>中</p>
<p>在<strong>Lighting.hlsl</strong>中，有一个<strong>GetMainLight</strong>函数，如果您熟悉着色器图中的自定义照明，您可能已经知道。为了使用此功能，我们首先在<strong>HLSLPROGRAM</strong>的顶部引用Lighting.hlsl文件，我还将添加一些<strong>multi_compile</strong>指令，这些指令提供了接收阴影所需的关键字。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _SHADOWS_SOFT</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们将需要顶点法线来处理阴影/光照，因此我们将它们添加到<strong>Attributes</strong>和<strong>Varyings</strong>结构中，并更新顶点着色器。在这里，我仅显示基于上一节中制作的Unlit着色器添加的代码。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Attributes &#123;</span><br><span class="line">    ...</span><br><span class="line">    float4 normalOS     : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct Varyings &#123;</span><br><span class="line">    ...</span><br><span class="line">    float3 normalWS     : NORMAL;</span><br><span class="line">    float3 positionWS   : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Varyings vert(Attributes IN) &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    VertexPositionInputs positionInputs = GetVertexPositionInputs(IN.positionOS.xyz);</span><br><span class="line">    ...</span><br><span class="line">    OUT.positionWS = positionInputs.positionWS;</span><br><span class="line"> </span><br><span class="line">    VertexNormalInputs normalInputs = GetVertexNormalInputs(IN.normalOS.xyz);</span><br><span class="line">    OUT.normalWS = normalInputs.normalWS;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片元着色器中，我们现在可以采用世界空间法线，并使用世界空间位置来计算阴影坐标。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(Varyings IN) : SV_Target &#123;</span><br><span class="line">    half4 baseMap = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line">    half4 color = baseMap * _BaseColor * IN.color;</span><br><span class="line"> </span><br><span class="line">    float4 shadowCoord = TransformWorldToShadowCoord(IN.positionWS.xyz);</span><br><span class="line">    Light light = GetMainLight(shadowCoord);</span><br><span class="line"> </span><br><span class="line">    half3 diffuse = LightingLambert(light.color, light.direction, IN.normalWS);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> half4(color.rgb * diffuse * light.shadowAttenuation, color.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们的着色器将从其他着色器接收阴影，但是请注意，它没有<strong>ShadowCaster</strong>传递，因此不会将阴影投射到自身或其他对象上。请参见<strong>ShadowCaster</strong>部分。</p>
<p>如果我们需要阴影，但对象上没有漫反射阴影，则也可以删除漫反射阴影计算，而只需使用<strong>light.shadowAttenuation</strong>。</p>
<p>如果要进一步扩展以包括环境/烘焙GI和其他光源，请以<strong>Lighting.hlsl</strong>中的<strong>UniversalFragmentBlinnPhong</strong>方法为例，或者让它为您处理照明。它使用<strong>InputData</strong>结构，下一部分讨论的PBR示例也将使用该结构。</p>
<h2 id="PBR光照"><a href="#PBR光照" class="headerlink" title="PBR光照"></a>PBR光照</h2><p>基于物理的渲染（PBR）是Unity的“Standard”着色器使用的着色/照明模型，以及UPR的“ Lit”着色器和ShaderGraph中的PBR主节点。</p>
<p>如前一节所述，内置管道中的阴影/照明通常由Surface Shaders处理，其中“Standard”选用是PBR模型。它们使用了一个曲面函数，该函数输出了<strong>反照率，法线，发射，平滑度，遮挡，Alpha和Metallic</strong>（如果使用“ StandardSpecular”工作流程，则为Specular）。Unity将采用这些并在幕后生成一个顶点和片段着色器，为您处理某些计算，例如PBR阴影/照明和阴影。</p>
<p>Universal RP不支持表面着色器，但是ShaderLibrary确实提供了帮助我们处理大量光照计算的功能。这些包含在<strong>Lighting.hlsl</strong>中。在本节中，我们将重点介绍<strong>UniversalFragmentPBR</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">half4 UniversalFragmentPBR(InputData inputData, half3 albedo, half metallic, half3 specular, half smoothness, half occlusion,  half3 emission, half alpha)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在v10.xx中添加了带有SurfaceData结构的版本</span></span><br><span class="line"><span class="comment">// 对于之前的版本，需要改用以上版本。</span></span><br><span class="line"><span class="comment">//（但是您仍然可以使用SurfaceData结构来组织/保存数据）</span></span><br><span class="line">half4 UniversalFragmentPBR(InputData inputData, SurfaceData surfaceData)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 还有:</span></span><br><span class="line">half4 UniversalFragmentBlinnPhong(InputData inputData, half3 diffuse, half4 specularGloss, half smoothness, half3 emission, half alpha)</span><br><span class="line"><span class="comment">//复制Unity v4之前的“旧”表面着色器，</span></span><br><span class="line"><span class="comment">//并由URP的“ SimpleLit”着色器使用</span></span><br><span class="line"><span class="comment">//使用Lambert（漫反射）和BlinnPhong（镜面反射）照明模型</span></span><br></pre></td></tr></table></figure>

<p>首先，我们应该添加PBR照明模型使用的一些属性。我省去了金属/高光贴图和遮挡贴图，主要是因为它们没有很好的功能来为您处理采样（除非您从LitInput.hlsl中复制它们，这是URP提供的Lit shader的一部分） ，而不是实际的ShaderLibrary），并且此部分已经相当长且足够复杂。实际上我几乎无法解释，因为它主要是知道在哪里使用哪个函数。您以后总是可以使用LitInput作为示例来添加它们。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _BaseMap (&quot;Base Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _BaseColor (&quot;Example Colour&quot;, Color) = (<span class="number">0</span>, <span class="number">0.66</span>, <span class="number">0.73</span>, <span class="number">1</span>)</span><br><span class="line">    _Smoothness (&quot;Smoothness&quot;, Float) = <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line">    [Toggle(_ALPHATEST_ON)] _EnableAlphaTest(&quot;Enable Alpha Cutoff&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">    _Cutoff (&quot;Alpha Cutoff&quot;, Float) = <span class="number">0.5</span></span><br><span class="line"> </span><br><span class="line">    [Toggle(_NORMALMAP)] _EnableBumpMap(&quot;Enable Normal/Bump Map&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">    _BumpMap (&quot;Normal/Bump Texture&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">    _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    [Toggle(_EMISSION)] _EnableEmission(&quot;Enable Emission&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">    _EmissionMap (&quot;Emission Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    _EmissionColor (&quot;Emission Colour&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// And need to adjust the CBUFFER to include these too</span></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">    float4 _BaseMap_ST; <span class="comment">// Texture tiling &amp; offset inspector values</span></span><br><span class="line">    float4 _BaseColor;</span><br><span class="line">    <span class="type">float</span> _BumpScale;</span><br><span class="line">    float4 _EmissionColor;</span><br><span class="line">    <span class="type">float</span> _Smoothness;</span><br><span class="line">    <span class="type">float</span> _Cutoff;</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure>

<p>我们还需要对Unlit着色器代码进行大量更改，包括添加一些<strong>multi_compile</strong>和<strong>shader_features</strong>以及对<strong>Attributes</strong>和<strong>Varyings</strong>结构进行调整，因为我们需要来自网格的法线和切线数据并将其发送到片元中以便使用它们用于照明计算。</p>
<p>“属性”块中的这些<strong>TOGGLE</strong>特性使我们能够从材质检查器启用/禁用shader_feature关键字。（或者，我们可以为着色器编写自定义编辑器/检查器GUI或使用调试检查器）。</p>
<p>如果要支持烘焙的光照贴图，我们还需要在<strong>TEXCOORD1</strong>通道中传递的<strong>光照贴图UV</strong>。</p>
<p>我还使用了来自ShaderLibrary的<strong>SurfaceInput.hlsl</strong>来帮助完成某些事情，它可以帮助<strong>SurfaceData</strong>结构保存PBR所需的数据以及一些用于采样的反射率，法线和发射贴图的函数（请注意，该结构似乎已经移动了到URP v10中的<strong>SurfaceData.hlsl</strong>，但SurfaceInput.hlsl会自动包含它）</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Material Keywords</span></span><br><span class="line"><span class="meta">#pragma shader_feature _NORMALMAP</span></span><br><span class="line"><span class="meta">#pragma shader_feature _ALPHATEST_ON</span></span><br><span class="line"><span class="meta">#pragma shader_feature _ALPHAPREMULTIPLY_ON</span></span><br><span class="line"><span class="meta">#pragma shader_feature _EMISSION</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _METALLICSPECGLOSSMAP</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _OCCLUSIONMAP</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _ENVIRONMENTREFLECTIONS_OFF</span></span><br><span class="line"><span class="comment">//#pragma shader_feature _SPECULAR_SETUP</span></span><br><span class="line"><span class="meta">#pragma shader_feature _RECEIVE_SHADOWS_OFF</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// URP Keywords</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _SHADOWS_SOFT</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unity defined keywords</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ DIRLIGHTMAP_COMBINED</span></span><br><span class="line"><span class="meta">#pragma multi_compile _ LIGHTMAP_ON</span></span><br><span class="line"><span class="meta">#pragma multi_compile_fog</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Some added includes, required to use the Lighting functions</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span><br><span class="line"><span class="comment">// And this one for the SurfaceData struct and albedo/normal/emission sampling functions.</span></span><br><span class="line"><span class="comment">// Note : It also defines the _BaseMap, _BumpMap and _EmissionMap textures for us, so we should use these as Shaderlab Properties too.</span></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&quot;</span></span><br><span class="line"> </span><br><span class="line">struct Attributes &#123;</span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS     : NORMAL;</span><br><span class="line">    float4 tangentOS    : TANGENT;</span><br><span class="line">    float4 color        : COLOR;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    float2 lightmapUV   : TEXCOORD1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct Varyings &#123;</span><br><span class="line">    float4 positionCS               : SV_POSITION;</span><br><span class="line">    float4 color                    : COLOR;</span><br><span class="line">    float2 uv                       : TEXCOORD0;</span><br><span class="line">    DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Note this macro is using TEXCOORD1</span></span><br><span class="line"><span class="meta">#ifdef REQUIRES_WORLD_SPACE_POS_INTERPOLATOR</span></span><br><span class="line">    float3 positionWS               : TEXCOORD2;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    float3 normalWS                 : TEXCOORD3;</span><br><span class="line"><span class="meta">#ifdef _NORMALMAP</span></span><br><span class="line">    float4 tangentWS                : TEXCOORD4;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    float3 viewDirWS                : TEXCOORD5;</span><br><span class="line">    half4 fogFactorAndVertexLight   : TEXCOORD6;</span><br><span class="line">    <span class="comment">// x: fogFactor, yzw: vertex light</span></span><br><span class="line"><span class="meta">#ifdef REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR</span></span><br><span class="line">    float4 shadowCoord              : TEXCOORD7;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//TEXTURE2D(_BaseMap);</span></span><br><span class="line"><span class="comment">//SAMPLER(sampler_BaseMap);</span></span><br><span class="line"><span class="comment">// Removed, since SurfaceInput.hlsl now defines the _BaseMap for us</span></span><br></pre></td></tr></table></figure>

<p>我们的“变量”现在还包含正在使用的光照贴图UV，法线和切线，但是我们还添加了“视图方向”，这对于照明计算，雾，顶点照明支持和接收阴影的阴影坐标是必不可少的。</p>
<p>现在我们需要更新顶点着色器以处理所有这些更改，这主要是仅知道要使用的功能：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if SHADER_LIBRARY_VERSION_MAJOR &lt; 9</span></span><br><span class="line">    <span class="comment">// This function was added in URP v9.x.x versions</span></span><br><span class="line">    <span class="comment">// If we want to support URP versions before, we need to handle it instead.</span></span><br><span class="line">    <span class="comment">// Computes the world space view direction (pointing towards the viewer).</span></span><br><span class="line">    float3 GetWorldSpaceViewDir(float3 positionWS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unity_OrthoParams.w == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Perspective</span></span><br><span class="line">            <span class="keyword">return</span> _WorldSpaceCameraPos - positionWS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Orthographic</span></span><br><span class="line">            float4x4 viewMat = GetWorldToViewMatrix();</span><br><span class="line">            <span class="keyword">return</span> viewMat[<span class="number">2</span>].xyz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">Varyings vert(Attributes IN) &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Vertex Position</span></span><br><span class="line">    VertexPositionInputs positionInputs = GetVertexPositionInputs(IN.positionOS.xyz);</span><br><span class="line">    OUT.positionCS = positionInputs.positionCS;</span><br><span class="line"><span class="meta">#ifdef REQUIRES_WORLD_SPACE_POS_INTERPOLATOR</span></span><br><span class="line">    OUT.positionWS = positionInputs.positionWS;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">// UVs &amp; Vertex Colour</span></span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    OUT.color = IN.color;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// View Direction</span></span><br><span class="line">    OUT.viewDirWS = GetWorldSpaceViewDir(positionInputs.positionWS);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Normals &amp; Tangents</span></span><br><span class="line">    VertexNormalInputs normalInputs = GetVertexNormalInputs(IN.normalOS, IN.tangentOS);</span><br><span class="line">    OUT.normalWS =  normalInputs.normalWS;</span><br><span class="line"><span class="meta">#ifdef _NORMALMAP</span></span><br><span class="line">    real <span class="built_in">sign</span> = IN.tangentOS.w * GetOddNegativeScale();</span><br><span class="line">    OUT.tangentWS = half4(normalInputs.tangentWS.xyz, <span class="built_in">sign</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Vertex Lighting &amp; Fog</span></span><br><span class="line">    half3 vertexLight = VertexLighting(positionInputs.positionWS, normalInputs.normalWS);</span><br><span class="line">    half fogFactor = ComputeFogFactor(positionInputs.positionCS.z);</span><br><span class="line">    OUT.fogFactorAndVertexLight = half4(fogFactor, vertexLight);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Baked Lighting &amp; SH (used for Ambient if there is no baked)</span></span><br><span class="line">    OUTPUT_LIGHTMAP_UV(IN.lightmapUV, unity_LightmapST, OUT.lightmapUV);</span><br><span class="line">    OUTPUT_SH(OUT.normalWS.xyz, OUT.vertexSH);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Shadow Coord</span></span><br><span class="line"><span class="meta">#ifdef REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR</span></span><br><span class="line">    OUT.shadowCoord = GetShadowCoord(positionInputs);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们还可以更新该片元着色器以实际使用<strong>UniversalFragmentPBR</strong>函数。由于它需要<strong>InputData</strong>结构输入，因此我们需要创建和设置它。代替在片元着色器中执行此操作，我们将创建另一个函数来帮助组织事物。</p>
<p>类似地，要处理所有反照率，金属，镜面，平滑度，遮挡，发射和Alpha输入，我们将使用<strong>SurfaceData</strong>结构（由我们之前包含的SurfaceInput.hlsl提供），并创建另一个函数来处理它。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">InputData InitializeInputData(Varyings IN, half3 normalTS)&#123;</span><br><span class="line">    InputData inputData = (InputData)<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)</span></span><br><span class="line">    inputData.positionWS = IN.positionWS;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">                 </span><br><span class="line">    half3 viewDirWS = SafeNormalize(IN.viewDirWS);</span><br><span class="line"><span class="meta">#ifdef _NORMALMAP</span></span><br><span class="line">    <span class="type">float</span> sgn = IN.tangentWS.w; <span class="comment">// should be either +1 or -1</span></span><br><span class="line">    float3 bitangent = sgn * <span class="built_in">cross</span>(IN.normalWS.xyz, IN.tangentWS.xyz);</span><br><span class="line">    inputData.normalWS = TransformTangentToWorld(normalTS, half3x3(IN.tangentWS.xyz, bitangent.xyz, IN.normalWS.xyz));</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    inputData.normalWS = IN.normalWS;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">    inputData.normalWS = NormalizeNormalPerPixel(inputData.normalWS);</span><br><span class="line">    inputData.viewDirectionWS = viewDirWS;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)</span></span><br><span class="line">    inputData.shadowCoord = IN.shadowCoord;</span><br><span class="line"><span class="meta">#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)</span></span><br><span class="line">    inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    inputData.shadowCoord = float4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">    inputData.fogCoord = IN.fogFactorAndVertexLight.x;</span><br><span class="line">    inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;</span><br><span class="line">    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);</span><br><span class="line">    <span class="keyword">return</span> inputData;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SurfaceData InitializeSurfaceData(Varyings IN)&#123;</span><br><span class="line">    SurfaceData surfaceData = (SurfaceData)<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Note, we can just use SurfaceData surfaceData; here and not set it.</span></span><br><span class="line">    <span class="comment">// However we then need to ensure all values in the struct are set before returning.</span></span><br><span class="line">    <span class="comment">// By casting 0 to SurfaceData, we automatically set all the contents to 0.</span></span><br><span class="line">         </span><br><span class="line">    half4 albedoAlpha = SampleAlbedoAlpha(IN.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap));</span><br><span class="line">    surfaceData.alpha = Alpha(albedoAlpha.a, _BaseColor, _Cutoff);</span><br><span class="line">    surfaceData.albedo = albedoAlpha.rgb * _BaseColor.rgb * IN.color.rgb;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Not supporting the metallic/specular map or occlusion map</span></span><br><span class="line">    <span class="comment">// for an example of that see : https://github.com/Unity-Technologies/Graphics/blob/master/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl</span></span><br><span class="line"> </span><br><span class="line">    surfaceData.smoothness = _Smoothness;</span><br><span class="line">    surfaceData.normalTS = SampleNormal(IN.uv, TEXTURE2D_ARGS(_BumpMap, sampler_BumpMap), _BumpScale);</span><br><span class="line">    surfaceData.emission = SampleEmission(IN.uv, _EmissionColor.rgb, TEXTURE2D_ARGS(_EmissionMap, sampler_EmissionMap));</span><br><span class="line">    surfaceData.occlusion = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> surfaceData;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">half4 frag(Varyings IN) : SV_Target &#123;</span><br><span class="line">    SurfaceData surfaceData = InitializeSurfaceData(IN);</span><br><span class="line">    InputData inputData = InitializeInputData(IN, surfaceData.normalTS);</span><br><span class="line">                 </span><br><span class="line">    <span class="comment">// In URP v10+ versions we could use this :</span></span><br><span class="line">    <span class="comment">// half4 color = UniversalFragmentPBR(inputData, surfaceData);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// But for other versions, we need to use this instead.</span></span><br><span class="line">    <span class="comment">// We could also avoid using the SurfaceData struct completely, but it helps to organise things.</span></span><br><span class="line">    half4 color = UniversalFragmentPBR(inputData, surfaceData.albedo, surfaceData.metallic, </span><br><span class="line">      surfaceData.specular, surfaceData.smoothness, surfaceData.occlusion, </span><br><span class="line">      surfaceData.emission, surfaceData.alpha);</span><br><span class="line">                 </span><br><span class="line">    color.rgb = MixFog(color.rgb, inputData.fogCoord);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// color.a = OutputAlpha(color.a);</span></span><br><span class="line">    <span class="comment">// Not sure if this is important really. It&#x27;s implemented as :</span></span><br><span class="line">    <span class="comment">// saturate(outputAlpha + _DrawObjectPassData.a);</span></span><br><span class="line">    <span class="comment">// Where _DrawObjectPassData.a is 1 for opaque objects and 0 for alpha blended.</span></span><br><span class="line">    <span class="comment">// But it was added in URP v8, and versions before just didn&#x27;t have it.</span></span><br><span class="line">    <span class="comment">// And I&#x27;m writing thing for v7.3.1 currently</span></span><br><span class="line">    <span class="comment">// We could still saturate the alpha to ensure it doesn&#x27;t go outside the 0-1 range though :</span></span><br><span class="line">    color.a = saturate(color.a);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前，虽然我们的着色器可以接收阴影，但它不包含ShadowCaster传递，因此不会投射任何阴影。这将在下一部分中处理。</p>
<h2 id="ShadowCaster-amp-DepthOnly-Passes"><a href="#ShadowCaster-amp-DepthOnly-Passes" class="headerlink" title="ShadowCaster &amp; DepthOnly Passes"></a>ShadowCaster &amp; DepthOnly Passes</h2><h3 id="SHADOWCASTER"><a href="#SHADOWCASTER" class="headerlink" title="SHADOWCASTER"></a>SHADOWCASTER</h3><p>如果我们希望着色器投射阴影，则需要通过标签“ <strong>LightMode</strong>” =“ <strong>ShadowCaster</strong>”的传递。可以在“Unlit”和“Lit”着色器上进行此操作，但要注意，尽管它们会投射阴影，但如果您不在<strong>UniversalForward</strong>Pass中处理阴影，它们将不会接收阴影。</p>
<p>除了使用<strong>UsePass</strong>时（在Shaderlab部分中已讨论过）。尽管我们可以使用其他着色器中的阴影投射器，例如UsePass“Universal Render Pipeline/Lit/ShadowCaster”，但由于该着色器中使用的CBUFFER可能不同，因此SRP Batcher兼容性可能会丢失。</p>
<p>相反，您应该自己定义这些Pass，有一个取巧的解决方法，我们可以执行以下操作：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;ShadowCaster&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot;=&quot;ShadowCaster&quot; &#125;</span><br><span class="line"> </span><br><span class="line">    ZWrite On</span><br><span class="line">    ZTest LEqual</span><br><span class="line"> </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="comment">// Required to compile gles 2.0 with standard srp library</span></span><br><span class="line">    <span class="meta">#pragma prefer_hlslcc gles</span></span><br><span class="line">    <span class="meta">#pragma exclude_renderers d3d11_9x gles</span></span><br><span class="line">    <span class="comment">//#pragma target 4.5</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Material Keywords</span></span><br><span class="line">    <span class="meta">#pragma shader_feature _ALPHATEST_ON</span></span><br><span class="line">    <span class="meta">#pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// GPU Instancing</span></span><br><span class="line">    <span class="meta">#pragma multi_compile_instancing</span></span><br><span class="line">    <span class="meta">#pragma multi_compile _ DOTS_INSTANCING_ON</span></span><br><span class="line">             </span><br><span class="line">    <span class="meta">#pragma vertex ShadowPassVertex</span></span><br><span class="line">    <span class="meta">#pragma fragment ShadowPassFragment</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl&quot;</span></span><br><span class="line"> </span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了<strong>ShadowCasterPass.hlsl</strong>中的函数，意味着定义该Pass较为容易，但是它需要使用**_BaseMap**，**_BaseColor**和**_Cutoff**属性，我们也需要将它们添加到**UnityPerMaterial CBUFFER**中。阴影投射器中的fragment函数仅在需要阴影的位置返回0，并丢弃不应有阴影的像素（请注意，仅在启用了**_ALPHATEST_ON**关键字的情况下才会发生裁剪）</p>
<p>如果我们的常规着色器通道也进行顶点位移，则也需要将其添加到ShadowCaster通道中，以便正确投射位移的阴影。为了解决这个问题，我们要么将ShadowCasterPass的内容复制到我们的过程中，要么只是定义一个新的顶点函数并交换#pragma顶点ShadowPassVertex。例如 ：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma vertex vert</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// function copied from ShadowCasterPass and edited slightly.</span></span><br><span class="line">Varyings vert(Attributes input) &#123;</span><br><span class="line">    Varyings output;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Example Displacement</span></span><br><span class="line">    input.positionOS += float4(<span class="number">0</span>, _SinTime.y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);</span><br><span class="line">    output.positionCS = GetShadowPositionHClip(input);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DEPTHONLY"><a href="#DEPTHONLY" class="headerlink" title="DEPTHONLY"></a>DEPTHONLY</h3><p>着色器还应包含标记为“ <strong>LightMode</strong>” =“ <strong>DepthOnly</strong>”的过程。此过程与<strong>ShadowCaster</strong>非常相似，但没有阴影偏差偏移。我不完全确定URP中使用<strong>DepthOnly</strong>传递的用途。场景视图似乎在渲染深度纹理时使用了它（由ShaderGraph中的“Scene Depth”节点使用），而“游戏视图”深度纹理在没有此传递的情况下似乎可以正常工作。但是，可能还有其他一些东西，例如自定义渲染功能（用于前向渲染器）依赖于DepthOnly传递。</p>
<p>我们可以以类似的方式处理DepthOnly传递，但有一些细微差异：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Name &quot;DepthOnly&quot;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot;=&quot;DepthOnly&quot; &#125;</span><br><span class="line"> </span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="comment">// Required to compile gles 2.0 with standard srp library</span></span><br><span class="line">    <span class="meta">#pragma prefer_hlslcc gles</span></span><br><span class="line">    <span class="meta">#pragma exclude_renderers d3d11_9x gles</span></span><br><span class="line">    <span class="comment">//#pragma target 4.5</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Material Keywords</span></span><br><span class="line">    <span class="meta">#pragma shader_feature _ALPHATEST_ON</span></span><br><span class="line">    <span class="meta">#pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// GPU Instancing</span></span><br><span class="line">    <span class="meta">#pragma multi_compile_instancing</span></span><br><span class="line">    <span class="meta">#pragma multi_compile _ DOTS_INSTANCING_ON</span></span><br><span class="line">             </span><br><span class="line">    <span class="meta">#pragma vertex DepthOnlyVertex</span></span><br><span class="line">    <span class="meta">#pragma fragment DepthOnlyFragment</span></span><br><span class="line">             </span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonMaterial.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&quot;</span></span><br><span class="line">    <span class="meta">#include &quot;Packages/com.unity.render-pipelines.universal/Shaders/DepthOnlyPass.hlsl&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Again, using this means we also need _BaseMap, _BaseColor and _Cutoff shader properties</span></span><br><span class="line">    <span class="comment">// Also including them in cbuffer, except _BaseMap as it&#x27;s a texture.</span></span><br><span class="line"> </span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次使用Unity的URP着色器提供的<strong>DepthOnlyPass</strong> 。同样，如果需要顶点位移，我们应该将<strong>DepthOnlyVertex</strong>函数复制到我们的代码中，将其重命名为vert，然后像上面的<strong>ShadowCaster</strong>示例中一样添加位移代码。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://fungusfox.gitee.io/p/%E4%BB%8Ebuilt-in%E5%88%B0urp/">https://fungusfox.gitee.io/p/%E4%BB%8Ebuilt-in%E5%88%B0urp/</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">阿卡林</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/">http://example.com/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">阿卡林</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/URP/">URP</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/22/002-URP%E6%89%8B%E5%86%8C/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">URP手册</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/21/hello-world/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/05/22/003-URP初试/" title="URP初试"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-22</div><div class="title">URP初试</div></div></a></div><div><a href="/2021/05/22/004-简单的Toon-Shader/" title="简易的卡通Shader"><img class="cover" src="https://drakari.top/2021/05/22/004-%E7%AE%80%E5%8D%95%E7%9A%84Toon-Shader/image-20210522121109858.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-22</div><div class="title">简易的卡通Shader</div></div></a></div><div><a href="/2021/05/22/002-URP手册/" title="URP手册"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-22</div><div class="title">URP手册</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">阿卡林</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DearestAKL"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HLSL%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">HLSL语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.</span> <span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">其他种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">1.7.</span> <span class="toc-text">宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tags"><span class="toc-number">2.</span> <span class="toc-text">Tags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93"><span class="toc-number">7.</span> <span class="toc-text">关键字和着色器变体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93"><span class="toc-number">7.1.</span> <span class="toc-text">着色器变体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93%E7%9A%84%E5%A2%9E%E9%95%BF"><span class="toc-number">7.1.1.</span> <span class="toc-text">着色器变体的增长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E5%8F%98%E4%BD%93%E4%B8%AA%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">如何查看着色器的变体个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.2.</span> <span class="toc-text">关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">8.</span> <span class="toc-text">光照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PBR%E5%85%89%E7%85%A7"><span class="toc-number">9.</span> <span class="toc-text">PBR光照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShadowCaster-amp-DepthOnly-Passes"><span class="toc-number">10.</span> <span class="toc-text">ShadowCaster &amp; DepthOnly Passes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SHADOWCASTER"><span class="toc-number">10.1.</span> <span class="toc-text">SHADOWCASTER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DEPTHONLY"><span class="toc-number">10.2.</span> <span class="toc-text">DEPTHONLY</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">引用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/004-%E7%AE%80%E5%8D%95%E7%9A%84Toon-Shader/" title="简易的卡通Shader"><img src="https://drakari.top/2021/05/22/004-%E7%AE%80%E5%8D%95%E7%9A%84Toon-Shader/image-20210522121109858.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简易的卡通Shader"/></a><div class="content"><a class="title" href="/2021/05/22/004-%E7%AE%80%E5%8D%95%E7%9A%84Toon-Shader/" title="简易的卡通Shader">简易的卡通Shader</a><time datetime="2021-05-22T04:00:00.000Z" title="发表于 2021-05-22 12:00:00">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/003-URP%E5%88%9D%E8%AF%95/" title="URP初试"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="URP初试"/></a><div class="content"><a class="title" href="/2021/05/22/003-URP%E5%88%9D%E8%AF%95/" title="URP初试">URP初试</a><time datetime="2021-05-22T03:00:00.000Z" title="发表于 2021-05-22 11:00:00">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/002-URP%E6%89%8B%E5%86%8C/" title="URP手册"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="URP手册"/></a><div class="content"><a class="title" href="/2021/05/22/002-URP%E6%89%8B%E5%86%8C/" title="URP手册">URP手册</a><time datetime="2021-05-22T02:00:00.000Z" title="发表于 2021-05-22 10:00:00">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/" title="从Built-in到URP"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从Built-in到URP"/></a><div class="content"><a class="title" href="/2021/05/22/001-%E4%BB%8EBuilt-in%E5%88%B0URP/" title="从Built-in到URP">从Built-in到URP</a><time datetime="2021-05-22T01:00:00.000Z" title="发表于 2021-05-22 09:00:00">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/21/hello-world/" title="Hello World"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2021/05/21/hello-world/" title="Hello World">Hello World</a><time datetime="2021-05-21T03:12:10.933Z" title="发表于 2021-05-21 11:12:10">2021-05-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 阿卡林</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>